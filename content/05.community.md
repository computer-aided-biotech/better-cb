## Level 3: Community

Tie to previous 2 sections

Main goal: develop and maintain a computational biology project with community engagement over time. Open research.

At this level, we can distinguish 3 sub-goals: Make your research accessible, reproducible and sustainable. The latter is especially relevant when part of the research involves developing code that will be used by others in the future (e.g. a tool or workflow), but we believe that many of those ideas are relevant to any computational biology project as well.

### 3.1. Make your research accessible

Making your research accessible is the first step towards open research. This include ensuring that anyone (inside or outside of academia) can access your research, and that your research stays available long after your paper is published. It is extremely frustrating to any researcher to look for software or a set of scripts from a paper published a few years ago, only to find a "404 error" where the code used to be provided. Even more frustrating is whenever authors offer code as "available on request"; this often leads to an email from the supervisor of the project (a professor) explaining that the developer of the code (a postdoc or PhD student) left years ago so the code is not available anymore.

There are three main ways in which people publish accompanying code to publications: As supplementary material in the publication it was used, via privately-owned domains, or via public repositories. The first option (publishing the code as supplementary material) has low accessibility if the paper is not open access, as only members of institutions that pay the journal membership will be able to access it. Moreover, it is completely static and cannot ever be updated if a new feature wants to be introduced, or a bug is found. The second option (privately-owned domains) lacks sustainability, as it requires certain maintenance, and either the domain can expire or the website might migrate somewhere else. Therefore, here we argue for the third option (public repositories) because of its accessibility and sustainability over time, as owners can update the code (if necessary) in a git-compliant way, and they don't need to rely on maintaining a domain and/or servers by themselves. As mentioned before (see [Level 2: Collaboration](#level-2-collaboration)), there are several hosting services for this purpose [@https://github.com; @https://gitlab.com; @https://bitbucket.org] (Table @tbl:community-tools-1), all equally valid depending on where people in your specific field usually publish their tools. However, as authors acquire more experience with Github [@https://github.com], in the following years many other repository-specific tools will be exemplified with Github.

| Goal | Tool options | Additional remarks |
|---|------|--------|
| Publish your code | &bull; **Github** [@https://github.com]<br/>&bull; **Gitlab** [@https://gitlab.com]<br/>&bull; **Bitbucket** [@https://bitbucket.org] | All three options allow you to host your repository online for free. Choose whichever is more used in your own field. |
| Share your code | &bull; Several licensing options [@https://choosealicense.com/licenses]. | Indicate with a license file what restrictions apply when using your code. If you don't include this, you will loose many users. |
| Archive your code | &bull; **Github Releases** [@https://docs.github.com/github/administering-a-repository/managing-releases-in-a-repository]<br/>&bull; **Zenodo** [@https://zenodo.org]: Provides DOI.<br/>&bull; **figshare** [@https://figshare.com/about]: Provides DOI. | Share progressive stable versions of your code as you develop it. Use **semantic versioning** [@https://semver.org] for assigning standard identifiers to your releases. |
| Publish a tool | &bull; **PyPI** [@https://pypi.org]: Python.<br/>&bull; **CRAN** [@https://cran.r-project.org]: R.<br/>&bull;  **Bioconductor** [@https://www.bioconductor.org]: R.<br/>&bull; **Bioconda** [@https://bioconda.github.io]: Language-agnostic. | Produce a package easy to install and use. Especially useful if you think you could have a userbase that will run the same analysis as you on other datasets and/or conditions. |
| Publish an interactive web app | &bull; **Dash** [@https://plotly.com/dash]: Python.<br/>&bull;  **R-Shiny** [@https://shiny.rstudio.com]: R. | Provide easy and interactive data exploration to your users. Especially useful if you have large datasets that can be explored in different ways. |

Table: Tools for making your research accessible. For each highlighted goal, different tools that achieve that goal, together with additional remarks, are shown. {#tbl:community-tools-1}

When publishing any piece of code online, adding a license that indicates how the code can be used is a crucial step (Table @tbl:community-tools-1). If not done, many researchers will not be able to use it. For instance, academic users will not know if they are entitled to use the code for their own research, and users from the industry will not know if the code can be used for profit. Many options exist for licensing code [@https://choosealicense.com/licenses], from permissive licenses that allow any kind of use with few or no conditions, like the Unlicense and MIT licenses, to more restrictive licenses that enforce disclosing the source and even requiring that any adaptation of the code uses the same license, like the GNU licenses. Our suggestion is to choose whatever suits your research group best; consider that as a rule of thumb, the more requirements you add, the less potential users you will have, but the more credit you will receive when users utilize your research for their own needs.

Working as a computational biologist, you will probably continue lines of work from scripts or software you have already published. Therefore, not only you should be interested in your code being accessible as a single instance, but instead provide ways of accessing numerous versions of your code. For instance, perhaps you improve performance of a given function, or add a new set of features entirely. To keep different versions of your code organized as you develop it, it is important to create and archive succeeding releases of your code (Table @tbl:community-tools-1). A good way to do this is with Github releases [@https://docs.github.com/github/administering-a-repository/managing-releases-in-a-repository], which requires minimal effort and shows all versions you have created of your code. An even better way to do this is with research repositories like Zenodo [@https://zenodo.org] or Figshare [@https://figshare.com/about], which not only store your code and data, but also give you a digital object identifier (DOI) for each version, making different versions of your code citable, in case the corresponding publication is not publicly available yet, or enough time has passed since the publication so that the current version of the code differs widely from what was published. These repositories can even be combined with code repositories, e.g. Github has a Zenodo integration that will trigger a new archived version every time a new release is made from Github. Regardless of the solution chosen, we recommend keeping some logical order to the releases, using a standard such as semantic versioning [@https://semver.org].

In most cases, it is probably enough to provide your code as an organized set of scripts and/or notebooks, for anyone to consult if they wish to reproduce and/or re-utilize your code. However, if you believe that your code would be partly or entirely used in a routinely fashion by other researchers, for instance for studying other organisms or other experimental conditions, you could consider packaging your code as a tool (Table @tbl:community-tools-1). If you take this route, aim for using one of the main options for publishing tools as packages: Bioconda [@https://bioconda.github.io] is a catch-all solution, but language-specific options also exist, such as PyPI [@https://pypi.org] if you work in Python, or CRAN [@https://cran.r-project.org] and Bioconductor [@https://www.bioconductor.org] if you work in R. All of these options will allow you to reach a bigger audience, as packages can be easily searched and installed locally with minimal effort.

Another common situation in research projects is, instead of having code that can be used by others to analyze their data, having data that can be analyzed in many ways. As producing plots that display the data in every conceivable way is unfeasible, a good solution here is to develop an interactive web app (Table @tbl:community-tools-1)—also referred to as a data dashboard—that lets users interact with the data, by showing different sets of variables or changing parameter settings (e.g. the significance of a statistical test). Common options for this goal are Dash [@https://plotly.com/dash] for Python and R Shiny [@https://shiny.rstudio.com] for R.

### 3.2. Make your research reproducible

Value of reproducibility

Documentation (readthedocs (which uses sphinx), gitbook): Guide your users. Mention the 4 types of documentation, denote differences between reStructuredText and markdown.

| Goal | Tool options | Additional remarks |
|---|-------|------|
| Document your code | &bull; **Readthedocs** [@https://readthedocs.org]: Uses **reStructuredText** [@https://docutils.sourceforge.io/rst.html].<br/>&bull; **Gitbook** [@https://www.gitbook.com]: Uses **Markdown** [@https://daringfireball.net/projects/markdown/syntax]. | Comprehensive documentation: from usage instructions to function documentation based on all compiled **docstrings** [@https://www.geeksforgeeks.org/python-docstrings]. |
| Reproducible environments | &bull; **Environment managers**: See Table XXX.<br/>&bull; **pip-tools** [@https://github.com/jazzband/pip-tools]: Administer several environments in a single project. | As a recommendation, try having the minimum number of dependencies needed to reproduce your results. |
| Reproducible code | &bull; **Docker** [@https://www.docker.com]<br/>&bull; **Singularity** [@https://sylabs.io] | Package your research as a container ready to run in any computer. |
| Reproducible notebooks | &bull; **Binder** [@https://mybinder.org] | Make your notebooks interactive and reproducible. |
| Reproducible pipelines | &bull; **Make** [@https://www.gnu.org/software/make] | Build a program by following a series of steps in a single Makefile. |
| Reproducible workflows | &bull; **Snakemake** [@https://snakemake.readthedocs.io]: Uses a Python-based language.<br/>&bull; **Nextflow** [@https://www.nextflow.io]: Uses **Groovy** [@https://groovy-lang.org]. | Run a pipeline of commands on NGS data in a reproducible way. |

Table: Tools for making your research reproducible. For each highlighted goal, different tools that achieve that goal, together with additional remarks, are shown. {#tbl:community-tools-2}

Docker/Singularity containers, pip-tools: Ensure your research is reproducible by anyone

Binder for reproducible notebooks

Developing reproducible workflows (Make, Snakemake, Nextflow)

### 3.3. Make your research sustainable

Goal: fostering a strong user community over time.

Welcome your users (readme, Github Pages)

| Goal | Tool options | Additional remarks |
|---|-----|-------|
| Welcome your users | &bull; **README file** [@https://www.makeareadme.com]: First file that shows up in a repository. <br/>&bull; **Github Pages** [@https://pages.github.com]: Separate website. | Provide a landing page to any repository with a short overview of the code (installation, usage, acknowledgments, etc). |
| Tell users how to contact you | &bull; **Gitter** [@https://gitter.im]: Specific questions.<br/>&bull; **Google groups** [@https://groups.google.com/forum/m]: Larger issues / how-to's. | Provide ways for users to contact you for questions, requests, etc. Remember to visit them periodically! |
| Track to-do's in your research | &bull; **Issues** [@https://guides.github.com/features/issues] | Detail specific pending to-do's in your research / allow others to request changes and/or highlight bugs. |
| Encourage user contributions | &bull; **Contribution guidelines** [@https://docs.github.com/github/building-a-strong-community/setting-guidelines-for-repository-contributors]: How to open issues / contribute code.<br/>&bull; **Github Wikis** [@https://docs.github.com/github/building-a-strong-community/about-wikis]: More specific how-to guides. | Provide as much information as you can to guide your users. You can also include administrator guidelines. |
| Foster a respectful community | &bull; **Contributor Covenant** [@https://www.contributor-covenant.org]: Smaller projects.<br/>&bull; **Citizen Code of Conduct** [@https://github.com/stumpsyn/policies/blob/master/citizen_code_of_conduct.md]: Larger projects. | Essential when you would like researchers to contribute code. |
| Keep track of your issues | &bull; **Github Projects** [@https://github.com/features/project-management]: Uses a **Kanban** [@https://www.atlassian.com/agile/kanban] flowchart.<br/>&bull; **Zenhub** [@https://www.zenhub.com]: Uses **Scrum** [@https://www.scrum.org/resources/what-is-scrum] practices. | Keep track of your pending tasks in different projects with **Agile** [@https://agilemanifesto.org] software development practices. Especially useful if your research is split in many different repositories, each with multiple features/fixes to do. |
| Branch your repo sustainably | &bull; **Gitflow** [@https://nvie.com/posts/a-successful-git-branching-model] | Useful when several developers contribute code to the project. Allows users to get access to stable versions of your research in an ongoing project. |

Table: Tools for making your research reproducible. For each highlighted goal, different tools that achieve that goal, together with additional remarks, are shown. {#tbl:community-tools-3}

Community engagement (Gitter, Google groups, other forums): Communicate with your users. You can have more than 1, for different purposes.

Issues (GitHub issues/milestones/labels/templates): Have a to-do list

Development Guidelines + wikis + code of conduct

Project management (GitHub projects, Zenhub, Agile, Scrum, Kanban): Maintain software and prioritize tasks

Full GitFlow (master/devel/hotfix branches): Ensure nothing breaks + Continuous integration (same as before but w/higher standards + automatic releasing): Do less, script more
