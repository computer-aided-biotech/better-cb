## Level 3: Community

Tie to previous 2 sections

Main goal: develop and maintain a computational biology project with community engagement over time. Open research.

At this level, we can distinguish 3 sub-goals: Make your research accessible, reproducible and sustainable. The latter is especially relevant when part of the research involves developing code that will be used by others in the future (e.g. a tool or workflow), but we believe that many of those ideas are relevant to any computational biology project as well.

### 3.1. Make your research accessible

Making your research accessible is the first step towards open research. This include ensuring that anyone (inside or outside of academia) can access your research, and that your research stays available long after your paper is published. It is extremely frustrating to any researcher to look for software or a set of scripts from a paper published a few years ago, only to find a "404 error" where the code used to be provided. Even more frustrating is whenever authors offer code as "available on request"; this often leads to an email from the supervisor of the project (a professor) explaining that the developer of the code (a postdoc or PhD student) left years ago so the code is not available anymore.

There are three main ways in which people publish accompanying code to publications: As supplementary material in the publication it was used, via privately-owned domains, or via public repositories. The first option (publishing the code as supplementary material) has low accessibility if the paper is not open access, as only members of institutions that pay the journal membership will be able to access it. Moreover, it is completely static and cannot ever be updated if a new feature wants to be introduced, or a bug is found. The second option (privately-owned domains) lacks sustainability, as it requires certain maintenance, and either the domain can expire or the website might migrate somewhere else. Therefore, here we argue for the third option (public repositories) because of its accessibility and sustainability over time, as owners can update the code (if necessary) in a git-compliant way, and they don't need to rely on maintaining a domain and/or servers by themselves. As mentioned before (see [Level 2: Collaboration](#level-2-collaboration)), there are several hosting services for this purpose [@https://github.com; @https://gitlab.com; @https://bitbucket.org] (Table @tbl:community-tools-1), all equally valid depending on where people in your specific field usually publish their tools. However, as authors acquire more experience with Github [@https://github.com], in the following years many other repository-specific tools will be exemplified with Github.

| Goal | Tool options | Additional remarks |
|---|------|--------|
| Publish your code | &bull; **Github** [@https://github.com]<br/>&bull; **Gitlab** [@https://gitlab.com]<br/>&bull; **Bitbucket** [@https://bitbucket.org] | All three options allow you to host your repository online for free. Choose whichever is more used in your own field. |
| Introduce your code | &bull; **README file** [@https://www.makeareadme.com]: First file that shows up in a repository. <br/>&bull; **Github Pages** [@https://pages.github.com]: Separate website. | Provide a landing page to any repository with a short overview of the code (installation, usage, acknowledgments, etc). |
| Share your code | &bull; Several licensing options [@https://choosealicense.com/licenses]. | Indicate with a license file what restrictions apply when using your code. If you don't include this, you will loose many users. |
| Archive your code | &bull; **Github Releases** [@https://docs.github.com/github/administering-a-repository/managing-releases-in-a-repository]<br/>&bull; **Zenodo** [@https://zenodo.org]: Provides DOI.<br/>&bull; **figshare** [@https://figshare.com/about]: Provides DOI. | Share progressive stable versions of your code as you develop it. Use **semantic versioning** [@https://semver.org] for assigning standard identifiers to your releases. |
| Publish a tool | &bull; **PyPI** [@https://pypi.org]: Python.<br/>&bull; **CRAN** [@https://cran.r-project.org]: R.<br/>&bull;  **Bioconductor** [@https://www.bioconductor.org]: R.<br/>&bull; **Bioconda** [@https://bioconda.github.io]: Language-agnostic. | Produce a package easy to install and use. Especially useful if you think you could have a userbase that will run the same analysis as you on other datasets and/or conditions. |
| Publish an interactive web app | &bull; **Dash** [@https://plotly.com/dash]: Python.<br/>&bull;  **R-Shiny** [@https://shiny.rstudio.com]: R. | Provide easy and interactive data exploration to your users. Especially useful if you have large datasets that can be explored in different ways. |

Table: Tools for making your research accessible. For each highlighted goal, different tools that achieve that goal, together with additional remarks, are shown. {#tbl:community-tools-1}

When publishing any piece of code online, there are two files that are fundamental to include: A readme file, and a license. Including a readme file [@https://www.makeareadme.com] is about welcoming your users, and introducing them to your code (Table @tbl:community-tools-1): it should include a description about its main intended usage, an overview of the installation, the most common commands, a way to contact the developers if problems arise (see [3.3. Make your research sustainable](#33-make-your-research-sustainable) for more details on this), and acknoledgments (if appropiate). We recommend to keep it short: You can include all the details in the documentation of the tool, here we only need a quick overview. The readme file, which can be written in different markup languages such as Markdown [@https://daringfireball.net/projects/markdown/syntax] or reStructuredText [@https://docutils.sourceforge.io/rst.html], will render automatically on the repository's landing page, below the repository file structure. For improved clarity, you may consider creating a separate landing page: it will declutter the look by only showing the information of the readme file, and use improved esthetics. All hosting services offer simple ways to do this; in the case of Github, with Github pages [@https://pages.github.com].

Adding a license to a repository is also a crucial step (Table @tbl:community-tools-1). Licenses indicate how the code can be used: Is it free to use for any application? Can users modify the code as they please? Does it come with a warranty that it will work? Can it be used for profit? If a license is not provided, many researchers will choose not to use the code at all. For instance, academic users will not know if they are entitled to modify the code for their own research, and users from the industry will not know if the code can be used for profit. Many options exist for licensing code [@https://choosealicense.com/licenses], from permissive licenses that allow any kind of use with few or no conditions, like the Unlicense and MIT licenses, to more restrictive licenses that enforce disclosing the source and even requiring that any adaptation of the code uses the same license, like the GNU licenses. Our suggestion is to choose whatever suits your research group best; consider that as a rule of thumb, the more requirements you add, the less potential users you will have, but the more credit you will receive when users utilize your research for their own needs.

Working as a computational biologist, you will probably continue lines of work from scripts or software you have already published. Therefore, not only you should be interested in your code being accessible as a single instance, but instead provide ways of accessing numerous versions of your code. For instance, perhaps you improve performance of a given function, or add a new set of features entirely. To keep different versions of your code organized as you develop it, it is important to create and archive succeeding releases of your code (Table @tbl:community-tools-1). A good way to do this is with Github releases [@https://docs.github.com/github/administering-a-repository/managing-releases-in-a-repository], which requires minimal effort and shows all versions you have created of your code. An even better way to do this is with research repositories like Zenodo [@https://zenodo.org] or Figshare [@https://figshare.com/about], which not only store your code and data, but also give you a digital object identifier (DOI) for each version, making different versions of your code citable, in case the corresponding publication is not publicly available yet, or enough time has passed since the publication so that the current version of the code differs widely from what was published. These repositories can even be combined with code repositories, e.g. Github has a Zenodo integration that will trigger a new archived version every time a new release is made from Github. Regardless of the solution chosen, we recommend keeping some logical order to the releases, using a standard such as semantic versioning [@https://semver.org].

In most cases, it is probably enough to provide your code as an organized set of scripts and/or notebooks, for anyone to consult if they wish to reproduce and/or re-utilize your code. However, if you believe that your code would be partly or entirely used in a routinely fashion by other researchers, for instance for studying other organisms or other experimental conditions, you could consider packaging your code as a tool (Table @tbl:community-tools-1). If you take this route, aim for using one of the main options for publishing tools as packages: Bioconda [@https://bioconda.github.io] is a catch-all solution, but language-specific options also exist, such as PyPI [@https://pypi.org] if you work in Python, or CRAN [@https://cran.r-project.org] and Bioconductor [@https://www.bioconductor.org] if you work in R. All of these options will allow you to reach a bigger audience, as packages can be easily searched and installed locally with minimal effort.

Another common situation in research projects is, instead of having code that can be used by others to analyze their data, having data that can be analyzed in many ways. As producing plots that display the data in every conceivable way is unfeasible, a good solution here is to develop an interactive web app (Table @tbl:community-tools-1)—also referred to as a data dashboard—that lets users interact with the data, by showing different sets of variables or changing parameter settings (e.g. the significance of a statistical test). Common options for this goal are Dash [@https://plotly.com/dash] for Python and R Shiny [@https://shiny.rstudio.com] for R.

### 3.2. Make your research reproducible

Having your code/data accessible to anyone is only the first step when sharing software to the research community; you also need for any analysis you have conducted to be reproducible by anyone. We have already discussed the importance of reproducibility in science when working in a personal project (see [Level 1: Personal Research](#level-1-personal-research)); however, when sharing your results with the academic community this becomes even more paramount, as your work should be able to be run by any other person, and be able to obtain the same results. This is especially relevant in science, as there is a constant number of people that are new to the field (including undergraduates, postgraduates and senior researchers), many who come from very different backgrounds to try to understand how your code, developed for your own specific niche research area, works.

A cornerstone for reproducibility is to have a solid documentation: by explaining what your code does, users can understand the intended use of each function, which will guide them on how to achieve your same results. We can distinguish 4 different levels of documentation [@https://documentation.divio.com/]:

* *Tutorials:* A group of lessons that teach the reader how to become a user of your code.
* *How-to guides:* A set of documents that clarify to a user how to solve common problems/tasks.
* *Explanations:* Discussions that clarify particular topics related to the code.
* *References:* Technical descriptions of your code variables/classes/functions.

The extent of documentation you write will depend on how many users you expect to have, and conversely will affect how many users you attract. If you foresee that your code has little usability outside of your research, perhaps a solid documentation of each function using docstrings [@https://www.geeksforgeeks.org/python-docstrings] could already be enough. However, you might also want to add a tutorial for a beginner, a couple of how-to guides for frequently used routines, and even some explanations for clarifying the science behind your code. The latter has the added bonus that it can be re-used for the eventual manuscript of your publication. If you are not sure how many users you might get, air on the side of caution and prepare good documentation anyways: You will be surprised to see how often other researchers contact you for reproducing your results and/or using your code for other applications! Finally, to publish comprehensive documentation online, consider using a) a standard documentation language such as reStructuredText [@https://docutils.sourceforge.io/rst.html] or Markdown [@https://daringfireball.net/projects/markdown/syntax], and b) a documentation platform such as Readthedocs [@https://readthedocs.org] or Gitbook [@https://www.gitbook.com] (Table @tbl:community-tools-1).

| Goal | Tool options | Additional remarks |
|---|-------|------|
| Document your code | &bull; **Readthedocs** [@https://readthedocs.org]: Uses **reStructuredText** [@https://docutils.sourceforge.io/rst.html].<br/>&bull; **Gitbook** [@https://www.gitbook.com]: Uses **Markdown** [@https://daringfireball.net/projects/markdown/syntax]. | Comprehensive documentation: from tutorials and how-to guides all the way down to function documentation based on all compiled **docstrings** [@https://www.geeksforgeeks.org/python-docstrings]. |
| Reproducible environments | &bull; **Environment managers**: See Table XXX.<br/>&bull; **pip-tools** [@https://github.com/jazzband/pip-tools]: Administer several environments in a single project. | As a recommendation, try having the minimum number of dependencies needed to reproduce your results. |
| Reproducible code | &bull; **Docker** [@https://www.docker.com]<br/>&bull; **Singularity** [@https://sylabs.io] | Package your research as a container ready to run in any computer. |
| Reproducible setup | &bull; **Make** [@https://www.gnu.org/software/make] | Build a program by following a series of steps in a single Makefile. |
| Reproducible notebooks | &bull; **Binder** [@https://mybinder.org] | Make your notebooks interactive and reproducible. |
| Reproducible pipelines | &bull; **Snakemake** [@https://snakemake.readthedocs.io]: Uses a Python-based language.<br/>&bull; **Nextflow** [@https://www.nextflow.io]: Uses **Groovy** [@https://groovy-lang.org]. | Run a pipeline of commands on NGS data in a reproducible way. |

Table: Tools for making your research reproducible. For each highlighted goal, different tools that achieve that goal, together with additional remarks, are shown. {#tbl:community-tools-2}

environments + pip-tools

Docker/Singularity containers + make: Ensure your research is reproducible by anyone

There are certain research projects where particular resources for ensuring reproducibility are especially useful: In the case that you have prepared most of your code using Jupyter notebooks, tools like Binder [@https://mybinder.org] allow you to publish interactive reproducible notebooks that anyone can run from their own setup. Finally, in the case you have developed a complex workflow, for example a pipeline for analyzing NGS data, tools like Snakemake [@https://snakemake.readthedocs.io] (which uses a Python-based language) or Nextflow [@https://www.nextflow.io] (which uses **Groovy** [@https://groovy-lang.org]) might be helpful.

### 3.3. Make your research sustainable

Goal: fostering a strong user community over time.


| Goal | Tool options | Additional remarks |
|---|-----|-------|
| Tell users how to contact you | &bull; **Gitter** [@https://gitter.im]: Specific questions.<br/>&bull; **Google groups** [@https://groups.google.com/forum/m]: Larger issues / how-to's. | Provide ways for users to contact you for questions, requests, etc. Remember to visit them periodically! |
| Track to-do's in your research | &bull; **Issues** [@https://guides.github.com/features/issues] | Detail specific pending to-do's in your research / allow others to request changes and/or highlight bugs. |
| Encourage user contributions | &bull; **Contribution guidelines** [@https://docs.github.com/github/building-a-strong-community/setting-guidelines-for-repository-contributors]: How to open issues / contribute code.<br/>&bull; **Github Wikis** [@https://docs.github.com/github/building-a-strong-community/about-wikis]: More specific how-to guides. | Provide as much information as you can to guide your users. You can also include administrator guidelines. |
| Foster a respectful community | &bull; **Contributor Covenant** [@https://www.contributor-covenant.org]: Smaller projects.<br/>&bull; **Citizen Code of Conduct** [@https://github.com/stumpsyn/policies/blob/master/citizen_code_of_conduct.md]: Larger projects. | Essential when you would like researchers to contribute code. |
| Keep track of your issues | &bull; **Github Projects** [@https://github.com/features/project-management]: Uses a **Kanban** [@https://www.atlassian.com/agile/kanban] flowchart.<br/>&bull; **Zenhub** [@https://www.zenhub.com]: Uses **Scrum** [@https://www.scrum.org/resources/what-is-scrum] practices. | Keep track of your pending tasks in different projects with **Agile** [@https://agilemanifesto.org] software development practices. Especially useful if your research is split in many different repositories, each with multiple features/fixes to do. |
| Branch your repo sustainably | &bull; **Gitflow** [@https://nvie.com/posts/a-successful-git-branching-model] | Useful when several developers contribute code to the project. Allows users to get access to stable versions of your research in an ongoing project. |

Table: Tools for making your research reproducible. For each highlighted goal, different tools that achieve that goal, together with additional remarks, are shown. {#tbl:community-tools-3}

Community engagement (Gitter, Google groups, other forums): Communicate with your users. You can have more than 1, for different purposes.

Issues (GitHub issues/milestones/labels/templates): Have a to-do list

Development Guidelines + wikis + code of conduct

Project management (GitHub projects, Zenhub, Agile, Scrum, Kanban): Maintain software and prioritize tasks

Full GitFlow (master/devel/hotfix branches): Ensure nothing breaks + Continuous integration (same as before but w/higher standards + automatic releasing): Do less, script more
